{
  "code": "let flying = 0;let isoAngleX; let isoAngleY; function project(x, y, z) {    let screenX = (x - y) * isoAngleX;    let screenY = (x + y) * isoAngleY - z;    return createVector(screenX, screenY);}function setup() {    createCanvas(windowWidth, windowHeight);    angleMode(RADIANS);    isoAngleX = cos(PI / 6);    isoAngleY = sin(PI / 6);}function draw() {    background(0);    let cSize = p.cellSize;    let cols = floor(width / cSize) + 40;    let rows = floor(height / cSize) + 40;    flying -= p.animationSpeed;    let terrain = [];    let yoff = flying;    for (let y = 0; y < rows; y++) {        terrain[y] = [];        let xoff = 0;        for (let x = 0; x < cols; x++) {            let heightValue = noise(xoff * p.noiseScale, yoff * p.noiseScale);            terrain[y][x] = map(heightValue, 0, 1, -p.terrainHeight, p.terrainHeight);            xoff += 1;        }        yoff += 1;    }    translate(width / 2, height / 2);    let offsetX = (-cols * cSize) / 2;    let offsetY = (-rows * cSize) / 2;    noFill();    colorMode(HSB, 360, 100, 100, 255);    let baseHue = 265;    for (let y = 0; y < rows; y++) {        for (let x = 0; x < cols; x++) {            let zA = terrain[y][x];            let xA = offsetX + x * cSize;            let yA = offsetY + y * cSize;            let pA = project(xA, yA, zA);            let saturation = map(zA, -p.terrainHeight, p.terrainHeight, 40, 100);            let brightness = map(zA, -p.terrainHeight, p.terrainHeight, 30, 100);            stroke(baseHue, saturation, brightness, p.wireframeOpacity);            strokeWeight(1);             if (x < cols - 1) {                let zB = terrain[y][x + 1];                let xB = offsetX + (x + 1) * cSize;                let yB = offsetY + y * cSize;                let pB = project(xB, yB, zB);                line(pA.x, pA.y, pB.x, pB.y);            }            if (y < rows - 1) {                let zC = terrain[y + 1][x];                let xC = offsetX + x * cSize;                let yC = offsetY + (y + 1) * cSize;                let pC = project(xC, yC, zC);                line(pA.x, pA.y, pC.x, pC.y);            }        }    }    for (let y = 0; y < rows; y++) {        for (let x = 0; x < cols; x++) {            let z = terrain[y][x];            let xW = offsetX + x * cSize;            let yW = offsetY + y * cSize;            let pP = project(xW, yW, z);            let hue = baseHue;            let saturation = map(z, -p.terrainHeight, p.terrainHeight, 50, 100);            let brightness = map(z, -p.terrainHeight, p.terrainHeight, 50, 100);            if (z > p.terrainHeight * 0.7) {                 hue = map(z, p.terrainHeight * 0.7, p.terrainHeight, baseHue, baseHue - 60);                 brightness = 100;            }            stroke(hue % 360, saturation, brightness, 255);            strokeWeight(p.strokeWeightFactor);            point(pP.x, pP.y);        }    }    colorMode(RGB, 255);}function windowResized() {    resizeCanvas(windowWidth, windowHeight);}",
  "info": {
    "name": "Synthesized Archipelago",
    "description": "A dynamic, wireframe topography emerges from the void, simulating abstract island chains generated by shifting noise fields and rendered in a high-fidelity isometric projection, reflecting a futuristic mapping system."
  },
  "parameters": [
    {
      "name": "cellSize",
      "label": "Grid Cell Size",
      "min": 5,
      "max": 50,
      "step": 1,
      "defaultValue": 10,
      "description": "Resolution of the underlying terrain grid. Smaller values create more detailed geometry but impact performance."
    },
    {
      "name": "noiseScale",
      "label": "Terrain Detail",
      "min": 0.001,
      "max": 0.1,
      "step": 0.001,
      "defaultValue": 0.02,
      "description": "Frequency of the Perlin noise, controlling the smoothness and roughness of the islands."
    },
    {
      "name": "terrainHeight",
      "label": "Height Amplitude",
      "min": 50,
      "max": 400,
      "step": 10,
      "defaultValue": 250,
      "description": "Maximum vertical exaggeration of the terrain features."
    },
    {
      "name": "animationSpeed",
      "label": "Evolution Speed",
      "min": 0.0001,
      "max": 0.05,
      "step": 0.001,
      "defaultValue": 0.01,
      "description": "Speed at which the noise field shifts, causing the islands to evolve and move over time."
    },
    {
      "name": "wireframeOpacity",
      "label": "Line Opacity (0-255)",
      "min": 50,
      "max": 255,
      "step": 5,
      "defaultValue": 180,
      "description": "Opacity of the wireframe lines connecting the terrain vertices."
    },
    {
      "name": "strokeWeightFactor",
      "label": "Point Thickness",
      "min": 0.5,
      "max": 5,
      "step": 0.1,
      "defaultValue": 1.5,
      "description": "Controls the visual size and weight of the vertices drawn on the grid."
    }
  ],
  "parameterValues": {
    "cellSize": 25,
    "noiseScale": 0.048,
    "terrainHeight": 400,
    "animationSpeed": 0.0491,
    "wireframeOpacity": 210,
    "strokeWeightFactor": 2.2
  }
}