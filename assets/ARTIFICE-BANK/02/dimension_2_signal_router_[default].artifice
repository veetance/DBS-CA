{
  "code": "let nodes = [];let particles = [];let cols, rows, cellSize;let currentGridDensity = 0;function getNode(i, j) {if (i >= 0 && i < cols && j >= 0 && j < rows) {return nodes[i + j * cols];}return null;}class Node {constructor(i, j) {this.i = i;this.j = j;this.x = (i + 0.5) * cellSize;this.y = (j + 0.5) * cellSize;this.rotation = 0;this.pulseTimer = floor(random(p.pulseFrequency));}update() {let noiseVal = noise(this.i * 0.1, this.j * 0.1, frameCount * p.rotationChaos * 0.001);this.rotation = map(noiseVal, 0, 1, 0, TWO_PI);this.pulseTimer++;if (this.pulseTimer >= p.pulseFrequency) {this.pulseTimer = 0;return true;}return false;}}class Particle {constructor(startNode) {this.history = [];this.currNode = startNode;this.targetNode = null;this.pos = createVector(startNode.x, startNode.y);this.nextPos = createVector(startNode.x, startNode.y);this.moveProgress = 1;this.life = 0;}findNextTarget() {if (!this.currNode) return false;let angle = this.currNode.rotation;let dirIndex = floor(((angle + PI / 4) % TWO_PI) / (PI / 2));let di = 0, dj = 0;if (dirIndex === 0) di = 1;else if (dirIndex === 1) dj = 1;else if (dirIndex === 2) di = -1;else if (dirIndex === 3) dj = -1;let nextI = this.currNode.i + di;let nextJ = this.currNode.j + dj;this.targetNode = getNode(nextI, nextJ);if (this.targetNode) {this.pos.set(this.currNode.x, this.currNode.y);this.nextPos.set(this.targetNode.x, this.targetNode.y);this.moveProgress = 0;this.currNode = this.targetNode;return true;} else {return false;}}update() {if (this.moveProgress >= 1) {this.history.push(this.pos.copy());if (!this.findNextTarget()) {return false;}this.moveProgress = 0;}this.moveProgress += p.signalSpeed;let t = min(this.moveProgress, 1);if (this.moveProgress > 0 && this.moveProgress < 1) {this.pos.x = lerp(this.pos.x, this.nextPos.x, t);this.pos.y = lerp(this.pos.y, this.nextPos.y, t);}this.history.push(this.pos.copy());while (this.history.length > p.connectionTrail) {this.history.shift();}return true;}display() {noFill();strokeWeight(1.5);for (let i = 0; i < this.history.length - 1; i++) {let alpha = map(i, 0, this.history.length - 1, 0, 255);let h = (p.hue + (this.currNode.i * 10) + (this.currNode.j * 5)) % 360;stroke(h, p.saturation, p.brightness, alpha);let p1 = this.history[i];let p2 = this.history[i+1];line(p1.x, p1.y, p2.x, p2.y);}fill(p.hue, p.saturation, p.brightness, 255);noStroke();ellipse(this.pos.x, this.pos.y, 4, 4);}}function setup() {createCanvas(windowWidth, windowHeight);colorMode(HSB, 360, 100, 100, 255);initializeGrid(p.gridDensity);}function initializeGrid(density) {currentGridDensity = density;let shorter = min(width, height);cellSize = shorter / density;cols = floor(width / cellSize);rows = floor(height / cellSize);nodes = [];for (let j = 0; j < rows; j++) {for (let i = 0; i < cols; i++) {let node = new Node(i, j);node.x = (i + 0.5) * cellSize;node.y = (j + 0.5) * cellSize;nodes.push(node);}}particles = [];}function draw() {if (p.gridDensity !== currentGridDensity) {initializeGrid(p.gridDensity);}background(0);for (let node of nodes) {if (node.update()) {particles.push(new Particle(node));}noStroke();let pulseFactor = map(node.pulseTimer, 0, p.pulseFrequency, 0.1, 0.5);let h = (p.hue + (node.i * 10) + (node.j * 5)) % 360;fill(h, p.saturation, p.brightness * pulseFactor, 100);ellipse(node.x, node.y, cellSize * 0.1, cellSize * 0.1);}for (let i = particles.length - 1; i >= 0; i--) {let particle = particles[i];if (particle.update()) {particle.display();} else {particles.splice(i, 1);}}}function windowResized() {resizeCanvas(windowWidth, windowHeight);initializeGrid(p.gridDensity);}",
  "info": {
    "name": "Signal Router [default]",
    "description": "A dynamic grid of conceptual synthesizer modules dictates the flow of luminous signals, creating complex, emergent trails and rhythmic, pulsing connections across the canvas.",
    "algorithm": "1. Initialize a grid of 'Nodes' where each node represents a module. Node positions are based on the calculated cell size derived from the 'gridDensity' parameter.\n2. Each Node maintains a 'pulseTimer' and a flow 'rotation' determined by Perlin noise, resulting in chaotic but continuous path changes based on 'rotationChaos'.\n3. When a Node's timer reaches 'pulseFrequency', it spawns a 'Particle' signal.\n4. Particles move by smoothly interpolating between Node centers. Upon reaching a Node, the Particle uses the Node's current quantized rotation (N, E, S, W) to determine its next target neighbor.\n5. The Particle leaves a fading trail behind it, stored in its 'history' array, constrained by 'connectionTrail'. The trail's color is derived from the global HSB controls and the particle's grid position."
  },
  "parameters": [
    {
      "name": "gridDensity",
      "label": "Module Density",
      "min": 5,
      "max": 30,
      "step": 1,
      "defaultValue": 15,
      "description": "The number of modules (nodes) packed along the shorter dimension, controlling the grid resolution."
    },
    {
      "name": "pulseFrequency",
      "label": "Clock Rate",
      "min": 10,
      "max": 100,
      "step": 1,
      "defaultValue": 40,
      "description": "Controls the frequency (in frames) at which modules spawn new signal particles. Lower values mean faster, denser flow."
    },
    {
      "name": "signalSpeed",
      "label": "Signal Speed",
      "min": 0.01,
      "max": 0.5,
      "step": 0.01,
      "defaultValue": 0.15,
      "description": "The interpolation speed of particles moving between module nodes."
    },
    {
      "name": "connectionTrail",
      "label": "Trail Length",
      "min": 1,
      "max": 20,
      "step": 1,
      "defaultValue": 8,
      "description": "The length and fading effect of the particle trails, simulating patch cables."
    },
    {
      "name": "rotationChaos",
      "label": "Routing Instability",
      "min": 0,
      "max": 1,
      "step": 0.01,
      "defaultValue": 0.3,
      "description": "Controls the speed at which the internal flow direction of each module changes, leading to different routing paths over time."
    }
  ],
  "parameterValues": {
    "gridDensity": 21,
    "pulseFrequency": 21,
    "signalSpeed": 0.27,
    "connectionTrail": 5,
    "rotationChaos": 0.15
  }
}